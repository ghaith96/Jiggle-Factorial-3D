<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Jiggle Factorial 3D</title>

  <!-- PWA Meta Tags -->
  <meta name="description" content="A cognitive training game using 3D multiple object tracking">
  <meta name="theme-color" content="#667eea">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Jiggle 3D">
  <link rel="manifest" href="/manifest.json">
  <link rel="icon" type="image/png" sizes="192x192" href="/icon-192.png">
  <link rel="icon" type="image/png" sizes="512x512" href="/icon-512.png">
  <link rel="apple-touch-icon" href="/icon-192.png">
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }

    #gui-container {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 1;
    }

    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 100;
    }

    #message {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-size: 48px;
      font-family: 'Arial Black', Arial, sans-serif;
      font-weight: bold;
      text-shadow:
        2px 2px 4px rgba(0, 0, 0, 0.8),
        0 0 15px rgba(102, 126, 234, 0.4);
      text-align: center;
      max-width: 90%;
      line-height: 1.2;
      pointer-events: none;
      z-index: 100;
      background: rgba(0, 0, 0, 0.5);
      padding: 12px 30px;
      border-radius: 10px;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
    }

    #message:empty {
      display: none;
    }

    #message.hidden {
      display: none !important;
    }

    @keyframes messageSlideIn {
      from {
        opacity: 0;
        transform: translateX(-50%) translateY(-20px);
      }

      to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }
    }

    @keyframes messagePulse {

      0%,
      100% {
        transform: translateX(-50%) scale(1);
      }

      50% {
        transform: translateX(-50%) scale(1.02);
      }
    }

    #message:not(:empty) {
      animation: messageSlideIn 0.3s ease-out;
    }

    #instructions {
      position: absolute;
      bottom: 20px;
      right: 20px;
      color: white;
      font-size: 16px;
      font-family: Arial, sans-serif;
      text-shadow: 1px 1px 2px black;
      max-width: 300px;
    }

    #average-display {
      position: absolute;
      bottom: 20px;
      left: 20px;
      color: white;
      font-size: 24px;
      font-family: Arial, sans-serif;
      text-shadow: 1px 1px 2px black;
      background: rgba(0, 0, 0, 0.5);
      padding: 12px 20px;
      border-radius: 8px;
    }

    #mobile-settings-button {
      display: none;
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(102, 126, 234, 0.9);
      color: white;
      border: none;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      font-size: 24px;
      cursor: pointer;
      z-index: 1001;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      transition: all 0.2s;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }

    #mobile-settings-button:active {
      transform: scale(0.95);
      background: rgba(102, 126, 234, 1);
    }

    #graph-popup {
      display: none;
      /* Hidden by default */
      position: fixed;
      top: 15%;
      left: 15%;
      width: 70%;
      height: 70%;
      background-color: rgba(0, 0, 0, 0.8);
      z-index: 2;
    }

    #graph-container {
      position: relative;
      width: 100%;
      height: 100%;
    }

    #progress-chart {
      width: 100%;
      height: 100%;
    }

    #close-graph-button {
      position: absolute;
      top: 5px;
      left: 5px;
      background-color: #d32f2f;
      color: white;
      font-size: 18px;
      border: 2px solid white;
      padding: 5px 10px;
      cursor: pointer;
      opacity: 0.9;
      font-weight: bold;
      border-radius: 4px;
    }

    #close-graph-button:hover {
      background-color: #b71c1c;
      opacity: 1;
    }

    #perf-monitor {
      position: absolute;
      top: 10px;
      left: 10px;
      background-color: rgba(0, 0, 0, 0.7);
      color: #00ff00;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      padding: 10px;
      border-radius: 5px;
      z-index: 1000;
      min-width: 150px;
      display: none;
      pointer-events: none;
    }

    #perf-monitor.visible {
      display: block;
    }

    #perf-monitor .perf-line {
      margin: 2px 0;
      display: flex;
      justify-content: space-between;
    }

    #perf-monitor .perf-label {
      margin-right: 10px;
    }

    #perf-monitor .perf-value {
      font-weight: bold;
    }

    #perf-monitor .perf-good {
      color: #00ff00;
    }

    #perf-monitor .perf-warning {
      color: #ffaa00;
    }

    #perf-monitor .perf-bad {
      color: #ff0000;
    }

    #loading-error {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(40, 40, 40, 0.95);
      color: #ff6b6b;
      padding: 30px;
      border-radius: 10px;
      border: 2px solid #ff6b6b;
      max-width: 500px;
      z-index: 10000;
      display: none;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      font-family: Arial, sans-serif;
    }

    #loading-error.visible {
      display: block;
    }

    #loading-error h2 {
      margin: 0 0 15px 0;
      color: #ff6b6b;
      font-size: 24px;
    }

    #loading-error p {
      margin: 10px 0;
      color: #fff;
      line-height: 1.5;
    }

    #loading-error .error-details {
      background-color: rgba(0, 0, 0, 0.3);
      padding: 10px;
      border-radius: 5px;
      margin: 10px 0;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      color: #ffcc00;
      max-height: 100px;
      overflow-y: auto;
    }

    #loading-error button {
      background-color: #667eea;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      margin-top: 15px;
    }

    #loading-error button:hover {
      background-color: #5568d3;
    }

    #center-dot {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      background-color: #FFFFFF;
      border: 2px solid #000000;
      border-radius: 50%;
      pointer-events: none;
      box-shadow: 0 0 4px rgba(0, 0, 0, 0.5);
    }

    .dg.main {
      background: rgba(40, 40, 40, 0.8);
    }

    .disabled {
      pointer-events: none;
      opacity: 0.5;
    }

    /* Mobile-first responsive design */
    @media (max-width: 768px) {
      #message {
        font-size: clamp(24px, 6vw, 36px);
        padding: 10px 20px;
        max-width: 85%;
        border-radius: 8px;
        top: 70px;
      }

      #instructions {
        display: none;
      }

      #average-display {
        font-size: 14px;
        bottom: 10px;
        left: 10px;
        right: 10px;
        text-align: center;
        background: rgba(0, 0, 0, 0.7);
        padding: 12px;
        border-radius: 8px;
      }

      #average-display>span {
        font-weight: bold;
      }

      #mobile-settings-button {
        display: block;
      }

      .dg.main {
        position: fixed !important;
        bottom: 0 !important;
        right: 0 !important;
        left: 0 !important;
        top: auto !important;
        width: 100% !important;
        max-height: 40vh;
        overflow-y: auto;
      }

      .dg.main .close-button {
        min-width: 44px;
        min-height: 44px;
      }

      /* Safe area for notched devices */
      #gui-container {
        padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
      }

      #center-dot {
        width: 10px !important;
        height: 10px !important;
      }

      #graph-popup {
        top: 5%;
        left: 5%;
        width: 90%;
        height: 90%;
      }

      #close-graph-button {
        min-width: 44px;
        min-height: 44px;
        padding: 10px 15px;
      }
    }

    /* Landscape mobile */
    @media (max-width: 768px) and (orientation: landscape) {
      #message {
        font-size: clamp(18px, 4vw, 28px);
        padding: 8px 16px;
        max-width: 80%;
        top: 10px;
      }

      .dg.main {
        max-height: 50vh;
      }
    }

    /* Small mobile devices */
    @media (max-width: 375px) {
      #message {
        font-size: clamp(20px, 5.5vw, 32px);
        padding: 10px 16px;
        max-width: 90%;
      }

      #average-display {
        font-size: 13px;
        padding: 10px;
      }

      #mobile-settings-button {
        width: 50px;
        height: 50px;
        font-size: 22px;
      }
    }
  </style>
</head>

<body>
  <!-- Mobile Settings Button -->
  <button id="mobile-settings-button" title="Settings">‚öôÔ∏è</button>
  <div id="gui-container"></div>
  <div id="overlay">
    <div id="message"></div>
    <!-- Center Dot -->
    <div id="center-dot"></div>
  </div>
  <div id="instructions">
    Scroll = Zoom, Left Mouse Drag = Rotate, Right Mouse Drag = Move (only works if you disable automatic screen
    rotation)
  </div>
  <div id="average-display">
    <span>Avg Score: N/A | Avg Accuracy: N/A%</span>
  </div>
  <!-- Loading Error Dialog -->
  <div id="loading-error">
    <h2>‚ö†Ô∏è Loading Error</h2>
    <p id="error-message">Failed to load required resources.</p>
    <div class="error-details" id="error-details"></div>
    <p>Please check your internet connection and try again.</p>
    <button onclick="location.reload()">Reload Page</button>
  </div>
  <!-- Popup for Graph -->
  <div id="graph-popup">
    <div id="graph-container">
      <canvas id="progress-chart"></canvas>
      <button id="close-graph-button">X</button>
    </div>
  </div>
  <!-- Loading Indicator -->
  <div id="loading-indicator" style="
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 20px 40px;
    border-radius: 10px;
    font-family: Arial, sans-serif;
    font-size: 18px;
    z-index: 1000;
    display: none;
  ">
    <div>Loading...</div>
    <div style="width: 200px; height: 4px; background: rgba(255,255,255,0.3); margin-top: 10px; border-radius: 2px;">
      <div id="loading-progress"
        style="width: 0%; height: 100%; background: #4CAF50; border-radius: 2px; transition: width 0.3s;"></div>
    </div>
  </div>
  <!-- Include Three.js and dat.GUI -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
      }
    }
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
  <!-- Include Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { FontLoader } from 'three/addons/loaders/FontLoader.js';
    import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

    // Import our custom modules
    import {
      shuffleArray,
      generateNonConsecutiveNumbers,
      showLoading,
      hideLoading,
      vibrateDevice,
      toggleFullscreen,
      isMobileDevice,
      isLowEndDevice,
      performancePresets
    } from './js/utils.js';
    import { BallPool, LabelPool } from './js/object-pools.js';
    import { TouchControls } from './js/touch-controls.js';
    import {
      storage,
      saveGameSettings,
      loadGameSettings,
      saveProgress,
      loadProgress,
      saveTrial,
      getAllTrials,
      exportToCSV,
      downloadCSV
    } from './js/storage.js';
    import {
      Easing,
      animateBallSelection,
      createParticleBurst,
      animateColorTransition,
      pulseBall,
      fadeObject,
      animationManager
    } from './js/animations.js';
    import {
      createPremiumLighting,
      animateLightForGameState,
      addDynamicLightAnimation,
      createLightFlash,
      updateLightingForPreset
    } from './js/lighting.js';

    // Make THREE globally available for debugging
    window.THREE = THREE;

    // Global Variables
    const sessionId = Date.now();
    let scene, camera, renderer, controls;
    let envMap;
    let gui;
    let balls = [];
    let targetBalls = [];
    let distractorBalls = [];
    let coloredDistractorBalls = [];
    let selectedBalls = [];
    let targetSequence = [];
    let userSequence = [];
    let isSequenceShowing = false;
    let isUserTurn = false;
    let defaultSettings;
    let settings;
    let raycaster = new THREE.Raycaster();
    let mouse = new THREE.Vector2();
    let messageElement = document.getElementById('message');
    let centerDotElement = document.getElementById('center-dot'); // Center Dot Element
    let screenRotationAngle = 0;
    let loadedFont; // Global variable to store the loaded font
    let activeTimeouts = []; // Array to store active timeouts
    let correctAnswersCount = 0;
    let incorrectAnswersCount = 0;
    let currentOrder = 'Ascending'; // Variable to store the current order
    let isGameStarting = false; // Prevent multiple initializations
    let flashModeTimeouts = []; // To store timeouts related to Flash Mode
    let mistakeMade = false; // Flag to track if a mistake has been made
    let speedBurstTimeouts = [];
    let speedBurstScheduled = false;
    let colorSwapTimeouts = [];
    let colorSwapScheduled = false;
    let activeColorSwaps = [];

    // New variables for score tracking
    let totalTrials = 0;
    let trialScores = [];
    let trialAccuracies = [];
    let cumulativeScore = 0;
    let cumulativeCorrectSelections = 0;
    let cumulativeTotalTargets = 0;

    const averageDisplayElement = document.getElementById('average-display');

    // Graph elements
    const graphPopup = document.getElementById('graph-popup');
    const closeGraphButton = document.getElementById('close-graph-button');

    // Object Pooling Classes (now imported from js/object-pools.js)
    // Keeping these here temporarily for reference, but using imported classes
    /*
    class BallPool {
      constructor() {
        this.pool = [];
        this.active = [];
        this.sharedGeometry = new THREE.SphereGeometry(1.5, 32, 32);
        this.sharedOutlineGeometry = new THREE.SphereGeometry(1.5 + 0.12, 32, 32);
      }

      initialize(maxSize) {
        // Pre-allocate balls
        for (let i = 0; i < maxSize; i++) {
          const ball = this.createBall();
          ball.visible = false;
          this.pool.push(ball);
          scene.add(ball); // Add to scene once
        }
      }

      createBall() {
        // Use shared geometry
        const material = new THREE.MeshStandardMaterial({
          metalness: 0.6,
          roughness: 0.65,
          emissive: "#FFFFFF",
          emissiveIntensity: 0.1,
        });
        const ball = new THREE.Mesh(this.sharedGeometry, material);
        ball.castShadow = true;
        ball.receiveShadow = true;
        ball.userData = {
          velocity: new THREE.Vector3(),
          isRotating: false,
          rotationGroup: 0,
          rotationAxis: '',
          originalColor: 0x87CEEB,
          rotationAngle: 0,
          isGameObject: true,
          isCurrentlyHighlighted: false,
          isFlashing: false,
          label: null
        };

        // Create outline once
        const outlineMaterial = new THREE.MeshBasicMaterial({
          color: 0x000000,
          side: THREE.BackSide,
          depthWrite: false,
          opacity: 0.5,
          transparent: true,
        });
        const outline = new THREE.Mesh(this.sharedOutlineGeometry, outlineMaterial);
        ball.add(outline);

        return ball;
      }

      acquire(color) {
        let ball;
        if (this.pool.length > 0) {
          ball = this.pool.pop();
        } else {
          ball = this.createBall();
          scene.add(ball);
        }
        ball.visible = true;
        ball.material.color.set(color);
        ball.userData.originalColor = color;
        this.active.push(ball);
        return ball;
      }

      release(ball) {
        ball.visible = false;
        // Reset ball state
        ball.position.set(0, 0, 0);
        ball.userData.velocity.set(0, 0, 0);
        ball.userData.isRotating = false;
        ball.userData.isCurrentlyHighlighted = false;
        ball.userData.isFlashing = false;
        ball.userData.rotationAngle = 0;
        ball.userData.rotationGroup = 0;
        ball.userData.rotationAxis = '';
        // Remove label if attached
        if (ball.userData.label) {
          labelPool.release(ball.userData.label);
          ball.remove(ball.userData.label);
          ball.userData.label = null;
        }
        const index = this.active.indexOf(ball);
        if (index > -1) {
          this.active.splice(index, 1);
          this.pool.push(ball);
        }
      }

      releaseAll() {
        // Create a copy of active array since release() modifies it
        const activeCopy = [...this.active];
        activeCopy.forEach(ball => this.release(ball));
      }
    }

    class LabelPool {
      constructor() {
        this.pool = {};
        this.active = [];
      }

      acquire(number) {
        if (!loadedFont) return null;

        const key = number.toString();
        let label = this.pool[key];

        if (!label) {
          label = this.createLabel(number);
          this.pool[key] = label;
        }

        // Clone the label for use
        const clonedLabel = label.clone();
        clonedLabel.visible = true;
        this.active.push(clonedLabel);
        return clonedLabel;
      }

      createLabel(number) {
        const geometry = new TextGeometry(number.toString(), {
          font: loadedFont,
          size: settings.numberSize,
          depth: settings.numberSize * 0.1,
        });

        const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const textMesh = new THREE.Mesh(geometry, material);

        geometry.computeBoundingBox();
        const centerOffsetX = -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);
        const centerOffsetY = -0.5 * (geometry.boundingBox.max.y - geometry.boundingBox.min.y);
        const offsetZ = 1.6 + settings.numberSize * 0.1;
        textMesh.position.set(centerOffsetX, centerOffsetY, offsetZ);
        textMesh.userData.isLabel = true;
        textMesh.visible = false; // Hidden by default

        return textMesh;
      }

      release(label) {
        if (!label) return;
        const index = this.active.indexOf(label);
        if (index > -1) {
          this.active.splice(index, 1);
        }
        label.visible = false;
      }

      releaseAll() {
        this.active.forEach(label => {
          label.visible = false;
        });
        this.active = [];
      }
    }
    */

    // Initialize pools (using imported classes)
    let ballPool = null;
    let labelPool = null;
    let touchControls = null;

    // Clock for delta time
    const clock = new THREE.Clock();

    // Device detection for memory optimization (using imported utils)
    const isMobile = isMobileDevice();
    const isLowEnd = isLowEndDevice();

    // Initialize with error handling
    try {
      init();
      animate();
      console.log('[Init] Application initialized successfully');
    } catch (error) {
      console.error('[Init] Fatal initialization error:', error);
      showLoadingError('general', `Initialization failed: ${error.message}\n${error.stack}`);
    }

    function init() {
      // Validate critical libraries are loaded
      if (typeof THREE === 'undefined') {
        throw new Error('Three.js library failed to load. Please check your internet connection.');
      }
      if (typeof dat === 'undefined') {
        throw new Error('dat.GUI library failed to load. Please check your internet connection.');
      }
      if (typeof Chart === 'undefined') {
        console.warn('[Loading] Chart.js library not loaded. Progress graph will be unavailable.');
      }

      console.log('[Init] All critical libraries loaded successfully');

      // Scene Setup
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x202020); // Dark gray background

      // Use environment map on desktop, simple color on low-end devices for memory savings
      if (isMobile || isLowEnd) {
        // Simple background for mobile - no HDRI loading
        scene.environment = null;
      } else {
        try {
          envMap = new THREE.TextureLoader().load(
            'hdri.jpg',
            (texture) => {
              texture.mapping = THREE.EquirectangularReflectionMapping;
              texture.colorSpace = THREE.SRGBColorSpace;
              console.log('[Loading] HDRI texture loaded successfully');
            },
            undefined,
            (error) => {
              console.warn('[Loading] HDRI texture failed to load, continuing without environment map:', error);
              // Don't show error dialog for HDRI as it's optional
              scene.environment = null;
            }
          );
          scene.environment = envMap;
        } catch (error) {
          console.warn('[Loading] Error loading HDRI:', error);
          scene.environment = null;
        }
      }

      // Camera Setup
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 60; // Set initial camera position

      // Renderer Setup - disable antialias on low-end devices for performance
      renderer = new THREE.WebGLRenderer({ antialias: !isLowEnd });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true; // Enable shadow mapping
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      // Controls
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.enableZoom = true;
      controls.enableRotate = true;
      controls.enablePan = true;

      // Premium lighting system with hemisphere, rim, and fill lights
      const lights = createPremiumLighting(scene, { isMobile });

      // Store lights globally for dynamic updates
      window.gameLights = lights;

      // Add dynamic light animation for premium feel
      addDynamicLightAnimation(lights);

      // Add point light to camera for better ball visibility
      const cameraLight = new THREE.PointLight(0xffffff, 0.3);
      camera.add(cameraLight);
      scene.add(camera);

      // GUI Setup
      defaultSettings = {
        level: 2,
        movementMode: 'Combination',
        verticalRotationGroups: 2,
        horizontalRotationGroups: 2,
        rotationSpeed: 0.01,
        isRandomMode: false,
        orderMode: 'Combined',
        isNonConsecutiveMode: true,
        autoProgression: true,
        showAnswers: true,
        isRegular3DMOT: false,
        numBlueDistractors: 5,
        numColoredDistractors: 5,
        ballSpeed: 0.1,
        boxSize: 50,
        screenRotation: true,
        screenRotationSpeed: 0.002,
        screenRotationDistance: 60,
        rotateX: true,
        rotateY: true,
        rotateZ: true,
        varyRotationDistance: false,
        highlightDuration: 1000,
        delayAfterSequence: 1000,
        numberSize: 3,
        dotSize: 5, // Center Dot Size
        showMessages: true, // Show game messages
        // Flash Mode settings
        flashMode: false,
        flashDurationMin: 160,
        flashDurationMax: 400,
        intervalDurationMin: 2000,
        intervalDurationMax: 3000,
        // Auto Progression settings
        // Level adjustment
        levelChangeByCorrect: 1,
        everyCorrectLevel: 1,
        levelChangeByIncorrect: -1,
        everyIncorrectLevel: 1,
        // Ball Speed adjustment
        ballSpeedChangeByCorrect: 0,
        everyCorrectBallSpeed: 1,
        ballSpeedChangeByIncorrect: 0,
        everyIncorrectBallSpeed: 1,
        // Highlight Duration adjustment
        highlightDurationChangeByCorrect: 0,
        everyCorrectHighlightDuration: 1,
        highlightDurationChangeByIncorrect: 0,
        everyIncorrectHighlightDuration: 1,
        // Delay Timer adjustment
        delayAfterChangeByCorrect: 0,
        everyCorrectDelayAfter: 1,
        delayAfterChangeByIncorrect: 0,
        everyIncorrectDelayAfter: 1,
        trialStartDelay: 2000,
        speedBurstMode: false,
        speedBurstFrequencyMin: 3000,
        speedBurstFrequencyMax: 7000,
        speedBurstMultiplierMin: 1.5,
        speedBurstMultiplierMax: 3.0,
        speedBurstDuration: 2000,
        speedBurstAffectTargetsOnly: false,
        speedBurstAffectPercentage: 50,
        speedBurstFrequencyChangeByCorrect: -200,
        everyCorrectSpeedBurst: 3,
        speedBurstFrequencyChangeByIncorrect: 200,
        everyIncorrectSpeedBurst: 2,
        speedBurstMultiplierChangeByCorrect: 0.1,
        speedBurstMultiplierChangeByIncorrect: -0.1,
        colorSwapMode: false,
        colorSwapFrequencyMin: 4000,
        colorSwapFrequencyMax: 8000,
        colorSwapDuration: 1000,
        colorSwapTargetBehavior: 'all',
        colorSwapAffectPercentage: 50,
        colorSwapVisualEffect: true,
        colorSwapFrequencyChangeByCorrect: -200,
        everyCorrectColorSwap: 3,
        colorSwapFrequencyChangeByIncorrect: 200,
        everyIncorrectColorSwap: 2,
        colorSwapAffectPercentageChangeByCorrect: 5,
        colorSwapAffectPercentageChangeByIncorrect: -5,
      };

      settings = {
        ...defaultSettings,
        startGame: startGame,
        resetApp: resetApp,
        exportSettings: exportSettings,
        importSettings: importSettings,
        showProgressGraph: showProgressGraph,
        exportData: exportData,
      }

      loadSettings();

      // Apply message visibility setting (don't save on init)
      updateMessageVisibility(false);

      gui = new dat.GUI({ autoPlace: false });
      document.getElementById('gui-container').appendChild(gui.domElement);

      gui.add(settings, 'level').name('Level');
      const movementModeController = gui.add(settings, 'movementMode', ['Non-Rotating', 'Rotating', 'Combination']).name('Movement Mode');
      movementModeController.__li.setAttribute('title', 'Choose how balls move: Non-Rotating, Rotating around the center of the screen, or a Combination of both.');
      const rotationFolder = gui.addFolder('Rotation Mode Settings');
      rotationFolder.add(settings, 'verticalRotationGroups').name('Vertical Groups');
      rotationFolder.add(settings, 'horizontalRotationGroups').name('Horizontal Groups');
      rotationFolder.add(settings, 'rotationSpeed').name('Rotation Speed');

      const randomModeController = gui.add(settings, 'isRandomMode').name('Random Mode');
      randomModeController.__li.setAttribute('title', 'When enabled, the target balls are selected in a random order, rather than ascending.');

      const orderModeController = gui.add(settings, 'orderMode', ['Ascending', 'Descending', 'Combined', 'Extended Combined']).name('Order Mode');

      const nonConsecutiveController = gui.add(settings, 'isNonConsecutiveMode').name('Non-Consecutive Mode');
      nonConsecutiveController.__li.setAttribute('title', 'When enabled,  the numbering of target balls might skip numbers (e.g. 1, 4, 56)');

      // Add the Regular 3D MOT toggle
      const regularMOTController = gui.add(settings, 'isRegular3DMOT').name('Regular 3D MOT Mode');
      regularMOTController.__li.setAttribute('title', 'When enabled, the order of ball selection does not matter');
      // Give it a special background color so it stands out
      regularMOTController.__li.style.backgroundColor = '#ffa500'; // or any unique color you like
      // Hide Random Mode, Order Mode, and Non-Consecutive Mode when isRegular3DMOT is true
      regularMOTController.onChange(value => {
        // Hide or show the existing controllers:
        randomModeController.domElement.parentNode.style.display = value ? 'none' : '';
        orderModeController.domElement.parentNode.style.display = value ? 'none' : '';
        nonConsecutiveController.domElement.parentNode.style.display = value ? 'none' : '';

        // Optionally, you might also want to reset their values if isRegular3DMOT is activated:
        // if (value) {
        //   settings.isRandomMode = false;
        //   settings.orderMode = 'Combined';
        //   settings.isNonConsecutiveMode = false;
        // }
      });


      gui.add(settings, 'showAnswers').name('Show Answers');
      gui.add(settings, 'showMessages').name('Show Messages').onChange(updateMessageVisibility);
      gui.add(settings, 'numBlueDistractors').name('# Blue Distractors');
      gui.add(settings, 'numColoredDistractors').name('# Colored Distractors');
      gui.add(settings, 'ballSpeed').name('Ball Speed');
      gui.add(settings, 'boxSize').name('Box Size');

      const screenRotationFolder = gui.addFolder('Screen Rotation');
      screenRotationFolder.add(settings, 'screenRotation').name('Enable');
      screenRotationFolder.add(settings, 'screenRotationSpeed').name('Speed');
      screenRotationFolder.add(settings, 'screenRotationDistance').name('Distance');
      screenRotationFolder.add(settings, 'rotateX').name('Rotate X');
      screenRotationFolder.add(settings, 'rotateY').name('Rotate Y');
      screenRotationFolder.add(settings, 'rotateZ').name('Rotate Z');
      screenRotationFolder.add(settings, 'varyRotationDistance').name('Vary Distance');

      gui.add(settings, 'highlightDuration').name('Highlight Duration');
      gui.add(settings, 'delayAfterSequence').name('Delay After');
      gui.add(settings, 'numberSize').name('Number Size');

      // Add Center Dot Size Controller
      gui.add(settings, 'dotSize').name('Center Dot Size').min(0).onChange(updateCenterDot);

      // Flash Mode GUI
      const flashModeFolder = gui.addFolder('Flash Mode Settings');
      flashModeFolder.add(settings, 'flashMode').name('Enable Flash Mode');
      flashModeFolder.add(settings, 'flashDurationMin').name('Flash Duration Min (ms)');
      flashModeFolder.add(settings, 'flashDurationMax').name('Flash Duration Max (ms)');
      flashModeFolder.add(settings, 'intervalDurationMin').name('Interval Min (ms)');
      flashModeFolder.add(settings, 'intervalDurationMax').name('Interval Max (ms)');

      // Auto Progression GUI
      const autoProgressionFolder = gui.addFolder('Auto Progression');
      autoProgressionFolder.add(settings, 'autoProgression').name('Enable');

      const levelAdjustmentFolder = autoProgressionFolder.addFolder('Level Adjustment');
      levelAdjustmentFolder.add(settings, 'levelChangeByCorrect').name('Change by');
      levelAdjustmentFolder.add(settings, 'everyCorrectLevel').name('Every Correct').min(1).step(1);
      levelAdjustmentFolder.add(settings, 'levelChangeByIncorrect').name('Change by');
      levelAdjustmentFolder.add(settings, 'everyIncorrectLevel').name('Every Incorrect').min(1).step(1);

      const ballSpeedAdjustmentFolder = autoProgressionFolder.addFolder('Ball Speed Adjustment');
      ballSpeedAdjustmentFolder.add(settings, 'ballSpeedChangeByCorrect').name('Change by');
      ballSpeedAdjustmentFolder.add(settings, 'everyCorrectBallSpeed').name('Every Correct').min(1).step(1);
      ballSpeedAdjustmentFolder.add(settings, 'ballSpeedChangeByIncorrect').name('Change by');
      ballSpeedAdjustmentFolder.add(settings, 'everyIncorrectBallSpeed').name('Every Incorrect').min(1).step(1);

      const highlightDurationAdjustmentFolder = autoProgressionFolder.addFolder('Highlight Duration Adjustment');
      highlightDurationAdjustmentFolder.add(settings, 'highlightDurationChangeByCorrect').name('Change by');
      highlightDurationAdjustmentFolder.add(settings, 'everyCorrectHighlightDuration').name('Every Correct').min(1).step(1);
      highlightDurationAdjustmentFolder.add(settings, 'highlightDurationChangeByIncorrect').name('Change by');
      highlightDurationAdjustmentFolder.add(settings, 'everyIncorrectHighlightDuration').name('Every Incorrect').min(1).step(1);

      const delayTimerAdjustmentFolder = autoProgressionFolder.addFolder('Delay Timer Adjustment');
      delayTimerAdjustmentFolder.add(settings, 'delayAfterChangeByCorrect').name('Change by');
      delayTimerAdjustmentFolder.add(settings, 'everyCorrectDelayAfter').name('Every Correct').min(1).step(1);
      delayTimerAdjustmentFolder.add(settings, 'delayAfterChangeByIncorrect').name('Change by');
      delayTimerAdjustmentFolder.add(settings, 'everyIncorrectDelayAfter').name('Every Incorrect').min(1).step(1);

      const speedBurstAdjustmentFolder = autoProgressionFolder.addFolder('Speed Burst Adjustment');
      speedBurstAdjustmentFolder.add(settings, 'speedBurstFrequencyChangeByCorrect').name('Frequency Change (Correct)');
      speedBurstAdjustmentFolder.add(settings, 'everyCorrectSpeedBurst').name('Every Correct').min(1).step(1);
      speedBurstAdjustmentFolder.add(settings, 'speedBurstFrequencyChangeByIncorrect').name('Frequency Change (Incorrect)');
      speedBurstAdjustmentFolder.add(settings, 'everyIncorrectSpeedBurst').name('Every Incorrect').min(1).step(1);
      speedBurstAdjustmentFolder.add(settings, 'speedBurstMultiplierChangeByCorrect').name('Multiplier Change (Correct)');
      speedBurstAdjustmentFolder.add(settings, 'speedBurstMultiplierChangeByIncorrect').name('Multiplier Change (Incorrect)');

      const colorSwapAdjustmentFolder = autoProgressionFolder.addFolder('Color Swap Adjustment');
      colorSwapAdjustmentFolder.add(settings, 'colorSwapFrequencyChangeByCorrect').name('Frequency Change (Correct)');
      colorSwapAdjustmentFolder.add(settings, 'everyCorrectColorSwap').name('Every Correct').min(1).step(1);
      colorSwapAdjustmentFolder.add(settings, 'colorSwapFrequencyChangeByIncorrect').name('Frequency Change (Incorrect)');
      colorSwapAdjustmentFolder.add(settings, 'everyIncorrectColorSwap').name('Every Incorrect').min(1).step(1);
      colorSwapAdjustmentFolder.add(settings, 'colorSwapAffectPercentageChangeByCorrect').name('Affect % Change (Correct)');
      colorSwapAdjustmentFolder.add(settings, 'colorSwapAffectPercentageChangeByIncorrect').name('Affect % Change (Incorrect)');

      const speedBurstFolder = gui.addFolder('Speed Burst Mode');
      speedBurstFolder.add(settings, 'speedBurstMode').name('Enable Speed Burst');
      speedBurstFolder.add(settings, 'speedBurstFrequencyMin').name('Frequency Min (ms)').min(500).step(100);
      speedBurstFolder.add(settings, 'speedBurstFrequencyMax').name('Frequency Max (ms)').min(500).step(100);
      speedBurstFolder.add(settings, 'speedBurstMultiplierMin').name('Multiplier Min').min(0.1).max(5.0).step(0.1);
      speedBurstFolder.add(settings, 'speedBurstMultiplierMax').name('Multiplier Max').min(0.1).max(5.0).step(0.1);
      speedBurstFolder.add(settings, 'speedBurstDuration').name('Duration (ms)').min(500).step(100);
      speedBurstFolder.add(settings, 'speedBurstAffectTargetsOnly').name('Affect Targets Only');
      speedBurstFolder.add(settings, 'speedBurstAffectPercentage').name('Affect Percentage').min(10).max(100).step(5);

      const colorSwapFolder = gui.addFolder('Color Swap Mode');
      colorSwapFolder.add(settings, 'colorSwapMode').name('Enable Color Swap');
      colorSwapFolder.add(settings, 'colorSwapFrequencyMin').name('Frequency Min (ms)').min(1000).step(100);
      colorSwapFolder.add(settings, 'colorSwapFrequencyMax').name('Frequency Max (ms)').min(1000).step(100);
      colorSwapFolder.add(settings, 'colorSwapDuration').name('Duration (ms)').min(500).step(100);
      colorSwapFolder.add(settings, 'colorSwapTargetBehavior', ['all', 'targetsOnly', 'distractorsOnly']).name('Target Behavior');
      colorSwapFolder.add(settings, 'colorSwapAffectPercentage').name('Affect Percentage').min(10).max(100).step(5);
      colorSwapFolder.add(settings, 'colorSwapVisualEffect').name('Visual Effect');

      const resetFolder = gui.addFolder('Settings Management');
      resetFolder.add(settings, 'exportSettings').name('Export Settings');
      resetFolder.add(settings, 'importSettings').name('Import Settings');
      resetFolder.add(settings, 'resetApp').name('Reset to Default');

      gui.add(settings, 'trialStartDelay').name('Trial Start Delay (ms)');

      // Add data/progress buttons
      const dataFolder = gui.addFolder('Data & Progress');
      dataFolder.add(settings, 'showProgressGraph').name('üìä Show Progress Graph');
      dataFolder.add(settings, 'exportData').name('üì• Export CSV Data');

      // Add "Start Game" button at the end
      gui.add(settings, 'startGame').name('Start Game');

      // Event Listeners
      window.addEventListener('resize', onWindowResize, false);
      renderer.domElement.addEventListener('pointerdown', onDocumentMouseDown, false);

      // Touch gesture handlers for mobile (using TouchControls class)
      touchControls = new TouchControls(camera, controls, renderer);
      touchControls.setIsUserTurnCallback(() => isUserTurn);
      touchControls.setup();

      gui.__controllers.forEach(controller => {
        controller.onChange((value) => {
          updateSettings();
          saveSettings();
        });
      });

      // Hide dat.GUI by default on mobile (user can still access premium panel)
      if (isMobile) {
        const guiContainer = document.getElementById('gui-container');
        if (guiContainer) {
          guiContainer.style.display = 'none';
        }

        // Mobile settings button toggle
        const mobileSettingsButton = document.getElementById('mobile-settings-button');
        if (mobileSettingsButton) {
          let touchHandled = false;

          const toggleSettings = (e) => {
            e.preventDefault();
            e.stopPropagation();

            if (guiContainer.style.display === 'none') {
              guiContainer.style.display = 'block';
              mobileSettingsButton.style.background = 'rgba(102, 126, 234, 1)';
            } else {
              guiContainer.style.display = 'none';
              mobileSettingsButton.style.background = 'rgba(102, 126, 234, 0.9)';
            }
          };

          // Handle touchstart to prevent event propagation to canvas
          mobileSettingsButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            e.stopPropagation();
            touchHandled = true;
          }, { passive: false });

          // Handle touchend for the actual toggle
          mobileSettingsButton.addEventListener('touchend', (e) => {
            if (touchHandled) {
              toggleSettings(e);
              touchHandled = false;
            }
          }, { passive: false });

          // Fallback to click for non-touch devices
          mobileSettingsButton.addEventListener('click', (e) => {
            if (!touchHandled) {
              toggleSettings(e);
            }
          }, { passive: false });
        }
      }

      // Event Listener for close graph button
      closeGraphButton.addEventListener('click', () => {
        graphPopup.style.display = 'none';
      });

      // Load the font once with loading indicator
      showLoading(0);
      const fontLoader = new FontLoader();
      fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json',
        function (font) {
          loadedFont = font;

          // Initialize object pools after font is loaded
          showLoading(70);
          ballPool = new BallPool(scene);
          labelPool = new LabelPool();
          labelPool.setFont(font);
          labelPool.setSettings(settings);
          ballPool.setLabelPool(labelPool);

          // Pre-allocate balls based on max possible (adjust as needed)
          const maxBalls = 50; // Max level + max distractors
          ballPool.initialize(maxBalls);

          showLoading(100);
          // Hide loading indicator after a brief delay for smooth transition
          setTimeout(() => {
            hideLoading();
            // Start the game after the font has loaded and pools initialized
            startGame();
          }, 200);
        },
        function (xhr) {
          // Progress callback
          if (xhr.lengthComputable) {
            const progress = (xhr.loaded / xhr.total) * 70; // 0-70%
            showLoading(progress);
          }
        },
        function (err) {
          console.error('An error happened loading the font:', err);

          // Initialize pools even if font fails
          ballPool = new BallPool(scene);
          labelPool = new LabelPool();
          labelPool.setSettings(settings);
          ballPool.setLabelPool(labelPool);
          ballPool.initialize(50);

          hideLoading();
          // Proceed to start the game even if font loading fails
          startGame();
        }
      );

      // Initialize the center dot
      updateCenterDot();

      // Update instructions for mobile
      const instructionsElement = document.getElementById('instructions');
      if (isMobile) {
        instructionsElement.textContent = 'Tap to select | Pinch to zoom | Two fingers to rotate';
      }
    }

    function updateCenterDot() {
      const size = settings.dotSize;
      if (size <= 0) {
        centerDotElement.style.display = 'none';
      } else {
        centerDotElement.style.display = 'block';
        centerDotElement.style.width = `${size}px`;
        centerDotElement.style.height = `${size}px`;
      }
    }

    function updateMessageVisibility(shouldSave = true) {
      if (!messageElement) return; // Guard clause if called before element is defined

      if (settings.showMessages) {
        messageElement.classList.remove('hidden');
      } else {
        messageElement.classList.add('hidden');
      }

      if (shouldSave) {
        saveSettings();
      }
    }

    // Error Handling
    function showLoadingError(errorType, errorDetails) {
      console.error('[Loading Error]', errorType, errorDetails);

      const errorDialog = document.getElementById('loading-error');
      const errorMessage = document.getElementById('error-message');
      const errorDetailsElement = document.getElementById('error-details');

      let message = 'Failed to load required resources.';

      switch (errorType) {
        case 'texture':
          message = 'Failed to load environment texture (HDRI).';
          break;
        case 'three':
          message = 'Failed to load Three.js library. Please check your internet connection.';
          break;
        case 'dat-gui':
          message = 'Failed to load GUI library. Please check your internet connection.';
          break;
        case 'chart':
          message = 'Failed to load Chart.js library. Some features may be unavailable.';
          break;
        case 'general':
          message = 'An unexpected error occurred during initialization.';
          break;
      }

      errorMessage.textContent = message;
      errorDetailsElement.textContent = errorDetails || 'No additional details available';
      errorDialog.classList.add('visible');
    }

    function hideLoadingError() {
      const errorDialog = document.getElementById('loading-error');
      errorDialog.classList.remove('visible');
    }

    // Global error handler
    window.addEventListener('error', (event) => {
      console.error('[Global Error]', event.error);

      // Check if it's a loading error
      if (event.message && event.message.includes('Failed to fetch')) {
        showLoadingError('general', `${event.message}\n${event.filename}:${event.lineno}`);
      }
    });

    // Unhandled promise rejection handler
    window.addEventListener('unhandledrejection', (event) => {
      console.error('[Unhandled Rejection]', event.reason);
      showLoadingError('general', `Promise rejection: ${event.reason}`);
    });

    function startGame() {
      if (isGameStarting) return; // Prevent multiple initializations
      isGameStarting = true;

      // Disable the Start Game button
      gui.__controllers.forEach(controller => {
        if (controller.property === 'startGame') {
          controller.__li.classList.add('disabled');
        }
      });

      // Clear previous timeouts and intervals
      activeTimeouts.forEach(timeout => clearTimeout(timeout));
      activeTimeouts = [];

      // Clear Flash Mode timeouts
      clearFlashModeTimeouts();

      // Clear game-specific objects
      clearGameObjects();

      // Reset game state variables
      isSequenceShowing = false;
      isUserTurn = false;
      messageElement.textContent = '';
      screenRotationAngle = 0;
      mistakeMade = false; // Reset mistake flag

      // Create Bounding Box
      createBoundingBox();

      // Create Balls
      createBalls();

      // Start Sequence
      let timeout = setTimeout(highlightTargetBalls, 1000);
      activeTimeouts.push(timeout);

      // Start Flash Mode if enabled
      startFlashMode();

      // Re-enable the Start Game button after initialization
      isGameStarting = false;
      gui.__controllers.forEach(controller => {
        if (controller.property === 'startGame') {
          controller.__li.classList.remove('disabled');
        }
      });
    }

    function clearGameObjects() {
      clearSpeedBurstTimeouts();
      clearColorSwapTimeouts();

      // Release all balls back to pool
      ballPool.releaseAll();

      // Release all labels back to pool
      labelPool.releaseAll();

      // Remove non-ball game objects (bounding box, etc.)
      for (let i = scene.children.length - 1; i >= 0; i--) {
        const obj = scene.children[i];
        // Only remove non-ball game objects (like bounding box)
        if (obj.userData.isGameObject && !ballPool.active.includes(obj) && !ballPool.pool.includes(obj)) {
          disposeObject(obj);
          scene.remove(obj);
        }
      }

      balls = [];
      targetBalls = [];
      distractorBalls = [];
      coloredDistractorBalls = [];
      selectedBalls = [];
      targetSequence = [];
      userSequence = [];
    }

    function disposeObject(obj) {
      if (obj.geometry) obj.geometry.dispose();
      if (obj.material) {
        if (Array.isArray(obj.material)) {
          obj.material.forEach(material => material.dispose());
        } else {
          obj.material.dispose();
        }
      }
      // Dispose of children recursively
      if (obj.children) {
        obj.children.forEach(child => disposeObject(child));
      }
    }

    function updateSettings() {
      // Update settings from GUI
      settings.level = Math.max(1, Math.round(settings.level));
      settings.numBlueDistractors = Math.round(settings.numBlueDistractors);
      settings.numColoredDistractors = Math.round(settings.numColoredDistractors);
      settings.verticalRotationGroups = Math.round(settings.verticalRotationGroups);
      settings.horizontalRotationGroups = Math.round(settings.horizontalRotationGroups);
    }

    function loadSettings() {
      const storedSettings = JSON.parse(localStorage.getItem('jiggle-3d-settings'));
      if (storedSettings) {
        Object.assign(settings, storedSettings);
      }
    }

    function saveSettings() {
      localStorage.setItem('jiggle-3d-settings', JSON.stringify(settings));
    }

    function repopulateGui() {
      gui.__controllers.forEach(controller => {
        controller.updateDisplay();
      });
    }

    function resetApp() {
      Object.assign(settings, defaultSettings);
      saveSettings();
      repopulateGui();
      startGame();
    }

    function exportSettings() {
      try {
        // Create export object with settings and metadata
        const exportData = {
          version: '1.0',
          exportDate: new Date().toISOString(),
          appName: 'Jiggle Factorial 3D',
          settings: { ...settings }
        };

        // Remove function properties that shouldn't be exported
        delete exportData.settings.startGame;
        delete exportData.settings.resetApp;

        // Convert to JSON
        const jsonString = JSON.stringify(exportData, null, 2);

        // Create blob and download
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
        link.download = `jiggle-3d-settings-${timestamp}.json`;
        link.href = url;
        link.click();

        // Clean up
        URL.revokeObjectURL(url);

        console.log('[Settings] Settings exported successfully');
        messageElement.textContent = 'Settings exported!';
        setTimeout(() => { messageElement.textContent = ''; }, 2000);
      } catch (error) {
        console.error('[Settings] Export failed:', error);
        messageElement.textContent = 'Export failed!';
        setTimeout(() => { messageElement.textContent = ''; }, 2000);
      }
    }

    function importSettings() {
      try {
        // Create file input
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';

        input.onchange = async (e) => {
          const file = e.target.files[0];
          if (!file) return;

          try {
            const text = await file.text();
            const importData = JSON.parse(text);

            // Validate import data
            if (!importData.settings) {
              throw new Error('Invalid settings file: missing settings object');
            }

            if (importData.appName !== 'Jiggle Factorial 3D') {
              const confirm = window.confirm('This file may not be from Jiggle Factorial 3D. Import anyway?');
              if (!confirm) return;
            }

            // Merge imported settings with current settings (preserving functions)
            const importedSettings = importData.settings;
            Object.keys(importedSettings).forEach(key => {
              if (key in settings && typeof settings[key] !== 'function') {
                settings[key] = importedSettings[key];
              }
            });

            // Save and apply
            saveSettings();
            repopulateGui();

            console.log('[Settings] Settings imported successfully');
            messageElement.textContent = 'Settings imported!';
            setTimeout(() => { messageElement.textContent = ''; }, 2000);
          } catch (error) {
            console.error('[Settings] Import failed:', error);
            messageElement.textContent = `Import failed: ${error.message}`;
            setTimeout(() => { messageElement.textContent = ''; }, 3000);
          }
        };

        // Trigger file picker
        input.click();
      } catch (error) {
        console.error('[Settings] Import error:', error);
        messageElement.textContent = 'Import error!';
        setTimeout(() => { messageElement.textContent = ''; }, 2000);
      }
    }

    function showProgressGraph() {
      graphPopup.style.display = 'block';
      renderProgressChart();
    }

    async function exportData() {
      try {
        showLoading(0);

        // Get all progress data
        const progressData = await storage.get('progressData') || [];

        if (progressData.length === 0) {
          alert('No data to export yet. Play some games first!');
          hideLoading();
          return;
        }

        showLoading(50);

        // Flatten the data for CSV export
        const flatData = [];
        progressData.forEach(day => {
          if (day.sessions) {
            day.sessions.forEach(session => {
              flatData.push({
                date: day.date,
                sessionId: session.sessionId,
                averageScore: session.sessionAverageScore,
                averageAccuracy: session.sessionAverageAccuracy,
                maxScore: session.sessionMaxScore,
                trialsCompleted: session.sessionTrialsCompleted
              });
            });
          } else {
            // Legacy format without sessions
            flatData.push({
              date: day.date,
              averageScore: day.averageScore,
              averageAccuracy: day.averageAccuracy,
              maxScore: day.maxScore,
              trialsCompleted: day.trialsCompleted
            });
          }
        });

        showLoading(80);

        // Convert to CSV
        const csv = exportToCSV(flatData);

        // Download CSV
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        downloadCSV(csv, `jiggle-factorial-${timestamp}.csv`);

        showLoading(100);
        setTimeout(hideLoading, 500);

        console.log('[Storage] Data exported successfully');
      } catch (error) {
        console.error('[Storage] Export failed:', error);
        alert('Failed to export data. See console for details.');
        hideLoading();
      }
    }

    function createBoundingBox() {
      const boxSize = settings.boxSize;

      // Create the solid box with slightly opaque walls
      const geometry = new THREE.BoxGeometry(boxSize, boxSize, boxSize);
      const material = new THREE.MeshPhongMaterial({
        color: 0x888888,
        transparent: true,
        opacity: 0.1, // Slightly opaque
        side: THREE.BackSide, // Render inside faces
      });
      const box = new THREE.Mesh(geometry, material);
      box.receiveShadow = true;
      box.userData.isGameObject = true; // Mark as game object
      scene.add(box);

      // Add thin white edges to the box
      const edges = new THREE.EdgesGeometry(geometry);
      const edgeMaterial = new THREE.LineBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.2,
      });
      const boundingBoxEdges = new THREE.LineSegments(edges, edgeMaterial);
      boundingBoxEdges.userData.isGameObject = true; // Mark as game object
      scene.add(boundingBoxEdges);
    }

    function createBalls() {
      const totalBalls = settings.level + settings.numBlueDistractors + settings.numColoredDistractors;

      // Create an array to store positions to prevent overlapping
      const positions = [];

      // Create Target Balls with staggered spawn animation
      for (let i = 0; i < settings.level; i++) {
        const ball = ballPool.acquire(0x4A90E2); // Brighter, more saturated blue - better visibility

        // Random non-overlapping position
        setNonOverlappingPosition(ball, positions);

        balls.push(ball);
        targetBalls.push(ball);

      }

      // Create Blue Distractor Balls with staggered spawn animation
      for (let i = 0; i < settings.numBlueDistractors; i++) {
        const ball = ballPool.acquire(0x4A90E2); // Brighter, more saturated blue - better visibility

        // Random non-overlapping position
        setNonOverlappingPosition(ball, positions);

        balls.push(ball);
        distractorBalls.push(ball);

      }

      // Create Colored Distractor Balls with staggered spawn animation
      for (let i = 0; i < settings.numColoredDistractors; i++) {
        // Exclude primary blue and highlight yellow (special feedback colors auto-excluded)
        const color = getRandomColor([0x4A90E2, 0xFFEB3B]);
        const ball = ballPool.acquire(color);

        // Random non-overlapping position
        setNonOverlappingPosition(ball, positions);

        balls.push(ball);
        coloredDistractorBalls.push(ball);

      }

      // Assign Movement after all balls are spawned
      const totalDelay = totalBalls * 50 + 500;
      setTimeout(() => assignMovement(), totalDelay);
    }

    function createBall(color) {
      const geometry = new THREE.SphereGeometry(1.5, 32, 32);
      const material = new THREE.MeshStandardMaterial({
        color: color,
        metalness: 0.6,
        roughness: 0.65,
        emissive: "#FFFFFF",
        emissiveIntensity: 0.1,
      });
      const ball = new THREE.Mesh(geometry, material);
      ball.castShadow = true;
      ball.receiveShadow = true;
      ball.userData = {
        velocity: new THREE.Vector3(),
        isRotating: false,
        rotationGroup: 0,
        rotationAxis: '',
        originalColor: color,
        rotationAngle: 0,
        isGameObject: true, // Mark as game object
        isCurrentlyHighlighted: false,
        isFlashing: false
      };

      const outlineGeometry = new THREE.SphereGeometry(1.5 + 0.12, 32, 32);
      const outlineMaterial = new THREE.MeshBasicMaterial({
        color: 0x000000,
        side: THREE.BackSide,
        depthWrite: false,
        opacity: 0.5,
        transparent: true,
      });
      const outline = new THREE.Mesh(outlineGeometry, outlineMaterial);
      ball.add(outline);

      return ball;
    }

    function setNonOverlappingPosition(ball, positions) {
      const maxAttempts = 100;
      let attempts = 0;
      let positionFound = false;

      while (!positionFound && attempts < maxAttempts) {
        attempts++;
        const halfBox = settings.boxSize / 2 - 5;
        ball.position.x = (Math.random() - 0.5) * (halfBox * 2);
        ball.position.y = (Math.random() - 0.5) * (halfBox * 2);
        ball.position.z = (Math.random() - 0.5) * (halfBox * 2);

        let overlapping = false;
        for (let pos of positions) {
          if (ball.position.distanceTo(pos) < 3) {
            overlapping = true;
            break;
          }
        }

        if (!overlapping) {
          positions.push(ball.position.clone());
          positionFound = true;
        }
      }
    }

    function assignMovement() {
      if (settings.movementMode === 'Combination') {
        // Randomly assign each ball to rotate or move randomly
        for (let ball of balls) {
          if (Math.random() < 0.5) {
            // Assign rotation movement to the ball
            assignRotationMovement([ball]);
          } else {
            // Assign random movement to the ball
            assignRandomMovement([ball]);
          }
        }
      } else if (settings.movementMode === 'Rotating') {
        // Assign rotation movement
        assignRotationMovement(balls);
      } else {
        // Assign random movement
        assignRandomMovement(balls);
      }

      startSpeedBurstMode();
      startColorSwapMode();
    }

    function assignRandomMovement(ballArray) {
      for (let ball of ballArray) {
        const direction = new THREE.Vector3(
          (Math.random() - 0.5),
          (Math.random() - 0.5),
          (Math.random() - 0.5)
        ).normalize();
        ball.userData.velocity.copy(direction.multiplyScalar(settings.ballSpeed));
        ball.userData.isRotating = false;
      }
    }

    function assignRotationMovement(ballArray) {
      for (let ball of ballArray) {
        ball.userData.isRotating = true;
        ball.userData.rotationAxis = Math.random() < 0.5 ? 'vertical' : 'horizontal';
        ball.userData.rotationRadius = 10 + Math.random() * 10; // Random radius between 10 and 20
        ball.userData.rotationAngle = Math.random() * Math.PI * 2; // Random starting angle
        ball.userData.rotationSpeed = (Math.random() > 0.5 ? 1 : -1) * settings.rotationSpeed;
      }
    }

    function highlightTargetBalls() {
      isSequenceShowing = true;
      let numbers = [];
      if (settings.isNonConsecutiveMode) {
        numbers = generateNonConsecutiveNumbers(settings.level);
      } else {
        for (let i = 1; i <= settings.level; i++) {
          numbers.push(i);
        }
      }

      // Assign numbers to target balls
      targetSequence = [];
      for (let i = 0; i < targetBalls.length; i++) {
        targetSequence.push({ ball: targetBalls[i], number: numbers[i] });
      }

      // Sort targetSequence by number (ascending)
      targetSequence.sort((a, b) => a.number - b.number);

      // Build highlightSequence from targetSequence
      let highlightSequence = [...targetSequence];

      // Shuffle the highlightSequence for Random Mode
      if (settings.isRandomMode) {
        highlightSequence = shuffleArray(highlightSequence);
      }

      let index = 0;
      function highlightNextBall() {
        if (index > 0) {
          // Reset previous ball appearance
          const previous = highlightSequence[index - 1];
          previous.ball.material.color.set(0x4A90E2);
          previous.ball.material.emissive.set(0xFFFFFF);
          previous.ball.material.emissiveIntensity = 0.1;
          previous.ball.scale.set(1, 1, 1); // Reset scale
          previous.ball.userData.isCurrentlyHighlighted = false; // Unmark as highlighted

          // Remove label
          disposeLabel(previous.ball.userData.label);
          previous.ball.remove(previous.ball.userData.label);
          previous.ball.userData.label = null;
        }
        if (index < highlightSequence.length) {
          // Highlight current ball with enhanced visual effects
          const current = highlightSequence[index];
          current.ball.material.color.set(0xFFFF00); // Bright yellow
          current.ball.material.emissive.set(0xFF4400); // Orange-red glow
          current.ball.material.emissiveIntensity = 0.8; // Strong glow
          current.ball.scale.set(1.2, 1.2, 1.2); // Make it larger
          current.ball.userData.isCurrentlyHighlighted = true; // Mark as highlighted

          // Add number label
          addNumberLabel(current.ball, current.number);
          index++;
          let timeout = setTimeout(highlightNextBall, settings.highlightDuration);
          activeTimeouts.push(timeout);
        } else {
          // End of sequence
          isSequenceShowing = false;
          // Reset last ball appearance and remove label
          const lastBall = highlightSequence[index - 1].ball;
          lastBall.material.color.set(0x4A90E2);
          lastBall.material.emissive.set(0xFFFFFF);
          lastBall.material.emissiveIntensity = 0.1;
          lastBall.scale.set(1, 1, 1); // Reset scale
          lastBall.userData.isCurrentlyHighlighted = false; // Unmark as highlighted
          disposeLabel(lastBall.userData.label);
          lastBall.remove(lastBall.userData.label);
          lastBall.userData.label = null;

          // Determine the order
          let possibleOrders;

          if (settings.orderMode === 'Descending') {
            currentOrder = 'Descending';
            targetSequence = targetSequence.slice().reverse();
          } else if (settings.orderMode === 'Combined') {
            // Original combined: choose Ascending or Descending
            currentOrder = Math.random() < 0.5 ? 'Ascending' : 'Descending';
            if (currentOrder === 'Descending') {
              targetSequence = targetSequence.slice().reverse();
            }
          } else if (settings.orderMode === 'Extended Combined' && settings.isRandomMode) {
            // Extended combined only applies if random mode is on
            // The four possible orders: Ascending, Descending, Presented, Reverse Presented
            // 'highlightSequence' represents the order they were presented.
            possibleOrders = ['Ascending', 'Descending', 'Presented', 'Reverse Presented'];
            currentOrder = possibleOrders[Math.floor(Math.random() * possibleOrders.length)];

            if (currentOrder === 'Ascending') {
              targetSequence = targetSequence.slice().sort((a, b) => a.number - b.number);
            } else if (currentOrder === 'Descending') {
              targetSequence = targetSequence.slice().sort((a, b) => b.number - a.number);
            } else if (currentOrder === 'Presented') {
              // Presented order: use the highlightSequence order as is
              // targetSequence should reflect the order they were highlighted
              // highlightSequence currently holds that order
              targetSequence = highlightSequence;
            } else if (currentOrder === 'Reverse Presented') {
              // Reverse of presented order
              targetSequence = highlightSequence.slice().reverse();
            }
          } else {
            // Default to Ascending if extended combined chosen but random mode not active, or any fallback
            currentOrder = 'Ascending';
            targetSequence = targetSequence.slice().sort((a, b) => a.number - b.number);
          }


          // Start delay before user can interact
          messageElement.textContent = 'Get Ready...';
          let timeout = setTimeout(() => {
            isUserTurn = true;
            mistakeMade = false; // Reset mistake flag
            if (settings.isRegular3DMOT) {
              messageElement.textContent = 'Select in any order';
            } else {
              messageElement.textContent = 'Your Turn! Select in ' + currentOrder + ' order.';
            }

            // Freeze balls
            freezeBalls();
          }, settings.delayAfterSequence);
          activeTimeouts.push(timeout);
        }
      }
      highlightNextBall();
    }

    function addNumberLabel(ball, number) {
      if (!loadedFont) return; // Ensure the font is loaded

      const label = labelPool.acquire(number);
      if (label) {
        ball.userData.label = label;
        ball.add(label);
      }
    }

    function disposeLabel(label) {
      if (label) {
        // Release label back to pool before disposing
        labelPool.release(label);
        // Note: Don't dispose geometry/material as they're shared in the pool
      }
    }

    function freezeBalls() {
      for (let ball of balls) {
        ball.userData.velocity.set(0, 0, 0);
        ball.userData.isRotating = false;
      }
    }

    function onDocumentMouseDown(event) {
      if (!isUserTurn) {
        if (!isSequenceShowing) {
          // During delay period
          messageElement.textContent = 'Please wait...';
          let timeout = setTimeout(() => {
            if (messageElement.textContent === 'Please wait...') {
              messageElement.textContent = '';
            }
          }, 1000); // Clear the message after 1 second
          activeTimeouts.push(timeout);
        }
        return;
      }

      event.preventDefault();

      // Calculate mouse position
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = - ((event.clientY - rect.top) / rect.height) * 2 + 1;

      // Raycasting - optimized to only check parent balls, not descendants
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(balls, false); // Only parent balls, not outlines

      if (intersects.length > 0) {
        const selectedObject = intersects[0].object;
        const parentBall = selectedObject; // No need to traverse since we only check parents

        // Check if already selected
        if (selectedBalls.includes(parentBall)) return;

        selectedBalls.push(parentBall);
        userSequence.push(parentBall);

        if (targetBalls.includes(parentBall)) {
          // Check if the selected ball is the correct one in the sequence
          if (parentBall === targetSequence[userSequence.length - 1].ball && !mistakeMade) {
            // Correct selection - vibrant green with glow
            parentBall.material.color.set(0x00FF00); // Bright vibrant green
            parentBall.material.emissive.set(0x00FF00); // Green glow
            parentBall.material.emissiveIntensity = 0.5; // Strong glow
            vibrateDevice(50); // Short vibration for correct selection
          } else {
            // Wrong sequence but correct target ball - vibrant orange with glow
            const targetColor = settings.isRegular3DMOT ? 0x00FF00 : 0xFF6600; // Vibrant green or orange
            const emissiveColor = settings.isRegular3DMOT ? 0x00FF00 : 0xFF6600;
            parentBall.material.color.set(targetColor);
            parentBall.material.emissive.set(emissiveColor);
            parentBall.material.emissiveIntensity = 0.5;
            mistakeMade = true;
            vibrateDevice([50, 50, 50]); // Pattern for wrong order
          }
        } else {
          // Player selected a distractor ball - vibrant red with glow
          parentBall.material.color.set(0xFF0000); // Bright vibrant red
          parentBall.material.emissive.set(0xFF0000); // Red glow
          parentBall.material.emissiveIntensity = 0.5; // Strong glow
          mistakeMade = true;
          vibrateDevice(200); // Long vibration for wrong ball
        }

        // Check if the player has selected enough balls
        if (userSequence.length === targetSequence.length) {
          isUserTurn = false;
          checkUserSequence();
        }
      }
    }

    /**
     * Calculate trial score based on user selections
     * @returns {Object} { isCorrect, trialScore, correctSelections }
     */
    function calculateTrialScore() {
      if (settings.isRegular3DMOT) {
        // Regular 3D MOT: Order doesn't matter, just check if all targets selected
        const allTargetsSelected = targetBalls.every(ball => userSequence.includes(ball));
        const includedDistractor = userSequence.some(ball => !targetBalls.includes(ball));
        const isCorrect = allTargetsSelected && !includedDistractor;

        const correctSelections = userSequence.filter(ball => targetBalls.includes(ball)).length;
        const trialScore = isCorrect ? settings.level : Math.max(settings.level - 1, 0);

        return { isCorrect, trialScore, correctSelections };
      } else {
        // Sequential mode: Order matters
        const correctSelections = userSequence.filter(ball => targetBalls.includes(ball)).length;

        if (!mistakeMade) {
          // Perfect sequence
          return {
            isCorrect: true,
            trialScore: settings.level,
            correctSelections: targetSequence.length
          };
        } else {
          // Mistake was made
          let trialScore;
          if (userSequence.some(ball => !targetBalls.includes(ball))) {
            // Selected a distractor
            trialScore = Math.max(settings.level - 1, 0);
          } else {
            // Correct balls but wrong order
            trialScore = settings.level - 0.5;
          }

          return {
            isCorrect: false,
            trialScore,
            correctSelections
          };
        }
      }
    }

    function checkUserSequence() {
      totalTrials++;
      cumulativeTotalTargets += targetSequence.length;

      // Calculate score using unified logic
      const { isCorrect, trialScore, correctSelections } = calculateTrialScore();

      cumulativeScore += trialScore;
      cumulativeCorrectSelections += correctSelections;

      if (isCorrect) {
        messageElement.textContent = 'Correct!';
        correctAnswersCount++;
        incorrectAnswersCount = 0;

        if (settings.autoProgression) {
          adjustSettingsBasedOnPerformance(true);
        }

        // Save trial data and restart
        saveTrialData(trialScore);
        let timeout = setTimeout(startGame, settings.trialStartDelay);
        activeTimeouts.push(timeout);
      } else {
        // Handle incorrect selection
        messageElement.textContent = settings.isRegular3DMOT ? 'Incorrect selection.' : 'Incorrect sequence.';
        incorrectAnswersCount++;
        correctAnswersCount = 0;

        if (settings.showAnswers) {
          showCorrectSequence();
        }

        if (settings.autoProgression) {
          adjustSettingsBasedOnPerformance(false);
        }

        // Save trial data and restart
        saveTrialData(trialScore);
        let timeout = setTimeout(startGame, settings.trialStartDelay);
        activeTimeouts.push(timeout);
      }
    }


    function saveTrialData(trialScore) {
      // Save score for this trial
      trialScores.push(trialScore);

      // Calculate accuracy for this trial
      const trialAccuracy = (userSequence.filter(ball => targetBalls.includes(ball)).length / targetSequence.length) * 100;
      trialAccuracies.push(trialAccuracy);

      // Update average after every trial
      updateAverageDisplay();

      // Save daily progress
      saveDailyProgress(trialScore);
    }

    function updateAverageDisplay() {
      const totalScore = trialScores.reduce((a, b) => a + b, 0);
      const averageScore = totalScore / trialScores.length;

      const totalAccuracy = trialAccuracies.reduce((a, b) => a + b, 0);
      const averageAccuracy = totalAccuracy / trialAccuracies.length;

      const spanElement = averageDisplayElement.querySelector('span');
      if (spanElement) {
        spanElement.textContent = `Avg Score: ${averageScore.toFixed(2)} | Avg Accuracy: ${averageAccuracy.toFixed(2)}%`;
      }
    }

    async function saveDailyProgress(trialScore) {
      const today = new Date().toISOString().split('T')[0];
      const progressData = await storage.get('progressData') || [];

      // Calculate average score and accuracy
      const totalScore = trialScores.reduce((a, b) => a + b, 0);
      const averageScore = totalScore / trialScores.length;
      const averageAccuracy = (cumulativeCorrectSelections / cumulativeTotalTargets) * 100;

      // Check if data for today already exists
      const todayDataIndex = progressData.findIndex(data => data.date === today);

      if (todayDataIndex >= 0) {
        // Update existing data
        const existingData = progressData[todayDataIndex];
        // Create a session data object for the current session
        const sessionData = {
          sessionId: sessionId,
          sessionAverageScore: averageScore,
          sessionAverageAccuracy: averageAccuracy,
          sessionMaxScore: trialScore,
          sessionTrialsCompleted: trialScores.length
        };


        // If no sessions array exists for today, create it
        if (!existingData.sessions) {
          existingData.sessions = [];
        }

        // Check if a session with the current sessionId already exists for today
        let existingSessionIndex = existingData.sessions.findIndex(s => s.sessionId === sessionId);

        if (existingSessionIndex >= 0) {
          // Update the existing session for this sessionId
          let existingSession = existingData.sessions[existingSessionIndex];
          existingSession.sessionAverageScore = averageScore;
          existingSession.sessionAverageAccuracy = averageAccuracy;
          existingSession.sessionMaxScore = Math.max(existingSession.sessionMaxScore, trialScore);
          existingSession.sessionTrialsCompleted = trialScores.length;
        } else {
          // Add a new session for this sessionId
          existingData.sessions.push(sessionData);
        }



        // Recalculate daily aggregates from all sessions of today
        const totalSessions = existingData.sessions.length;

        const dailyAvgScore = existingData.sessions.reduce((sum, s) => sum + s.sessionAverageScore, 0) / totalSessions;
        const dailyAvgAccuracy = existingData.sessions.reduce((sum, s) => sum + s.sessionAverageAccuracy, 0) / totalSessions;
        const dailyMaxScore = Math.max(...existingData.sessions.map(s => s.sessionMaxScore));
        const dailyTrialsCompleted = existingData.sessions.reduce((sum, s) => sum + s.sessionTrialsCompleted, 0);

        existingData.averageScore = dailyAvgScore;
        existingData.averageAccuracy = dailyAvgAccuracy;
        existingData.maxScore = dailyMaxScore;
        existingData.trialsCompleted = dailyTrialsCompleted;

      } else {
        // Add new data
        progressData.push({
          date: today,
          sessions: [{
            sessionAverageScore: averageScore,
            sessionAverageAccuracy: averageAccuracy,
            sessionMaxScore: trialScore,
            sessionTrialsCompleted: trialScores.length
          }],
          averageScore: averageScore,
          averageAccuracy: averageAccuracy,
          maxScore: trialScore,
          trialsCompleted: trialScores.length
        });

      }

      // Save to IndexedDB
      await storage.save('progressData', progressData);
    }

    async function renderProgressChart() {
      const ctx = document.getElementById('progress-chart').getContext('2d');

      // Retrieve data from IndexedDB
      const progressData = await storage.get('progressData') || [];

      const labels = progressData.map(data => data.date);
      const scores = progressData.map(data => data.averageScore);
      const accuracies = progressData.map(data => data.averageAccuracy);
      const maxScores = progressData.map(data => data.maxScore);
      const trialsCompleted = progressData.map(data => data.trialsCompleted);

      // Destroy existing chart instance if it exists
      if (window.myLineChart) {
        window.myLineChart.destroy();
      }

      window.myLineChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Average Score',
            data: scores,
            borderColor: 'rgba(75, 192, 192, 1)',
            fill: false,
            yAxisID: 'y-axis-1',
          }, {
            label: 'Average Accuracy (%)',
            data: accuracies,
            borderColor: 'rgba(255, 99, 132, 1)',
            fill: false,
            yAxisID: 'y-axis-2',
          }, {
            label: 'Max Score',
            data: maxScores,
            borderColor: 'rgba(255, 206, 86, 1)',
            fill: false,
            yAxisID: 'y-axis-1', // Same axis as average score
          }, {
            label: 'Trials Completed',
            data: trialsCompleted,
            borderColor: 'rgba(153, 102, 255, 1)',
            fill: false,
            yAxisID: 'y-axis-3',
          }]
        },
        options: {
          scales: {
            yAxes: [{
              type: 'linear',
              position: 'left',
              id: 'y-axis-1',
              ticks: {
                beginAtZero: true,
                suggestedMax: Math.max(...maxScores) + 2
              },
              scaleLabel: {
                display: true,
                labelString: 'Score'
              }
            }, {
              type: 'linear',
              position: 'right',
              id: 'y-axis-2',
              ticks: {
                max: 100,
                min: 0
              },
              gridLines: {
                drawOnChartArea: false,
              },
              scaleLabel: {
                display: true,
                labelString: 'Accuracy (%)'
              }
            }, {
              type: 'linear',
              position: 'right',
              id: 'y-axis-3',
              ticks: {
                beginAtZero: true,
                suggestedMax: Math.max(...trialsCompleted) + 2
              },
              gridLines: {
                drawOnChartArea: false,
              },
              scaleLabel: {
                display: true,
                labelString: 'Trials Completed'
              }
            }]
          }
        }
      });
    }

    function adjustSettingsBasedOnPerformance(isCorrect) {
      if (isCorrect) {
        // Correct Answer Adjustments
        if (correctAnswersCount % settings.everyCorrectLevel === 0) {
          settings.level += settings.levelChangeByCorrect;
          settings.level = Math.max(1, settings.level);
        }
        if (settings.ballSpeedChangeByCorrect !== 0 && correctAnswersCount % settings.everyCorrectBallSpeed === 0) {
          settings.ballSpeed += settings.ballSpeedChangeByCorrect;
        }
        if (settings.highlightDurationChangeByCorrect !== 0 && correctAnswersCount % settings.everyCorrectHighlightDuration === 0) {
          settings.highlightDuration += settings.highlightDurationChangeByCorrect;
        }
        if (settings.delayAfterChangeByCorrect !== 0 && correctAnswersCount % settings.everyCorrectDelayAfter === 0) {
          settings.delayAfterSequence += settings.delayAfterChangeByCorrect;
        }

        if (settings.speedBurstMode && correctAnswersCount % settings.everyCorrectSpeedBurst === 0) {
          settings.speedBurstFrequencyMin += settings.speedBurstFrequencyChangeByCorrect;
          settings.speedBurstFrequencyMax += settings.speedBurstFrequencyChangeByCorrect;
          settings.speedBurstFrequencyMin = Math.max(500, settings.speedBurstFrequencyMin);
          settings.speedBurstFrequencyMax = Math.max(500, settings.speedBurstFrequencyMax);

          settings.speedBurstMultiplierMax += settings.speedBurstMultiplierChangeByCorrect;
          settings.speedBurstMultiplierMax = Math.min(5.0, Math.max(0.1, settings.speedBurstMultiplierMax));
        }

        if (settings.colorSwapMode && correctAnswersCount % settings.everyCorrectColorSwap === 0) {
          settings.colorSwapFrequencyMin += settings.colorSwapFrequencyChangeByCorrect;
          settings.colorSwapFrequencyMax += settings.colorSwapFrequencyChangeByCorrect;
          settings.colorSwapFrequencyMin = Math.max(1000, settings.colorSwapFrequencyMin);
          settings.colorSwapFrequencyMax = Math.max(1000, settings.colorSwapFrequencyMax);

          settings.colorSwapAffectPercentage += settings.colorSwapAffectPercentageChangeByCorrect;
          settings.colorSwapAffectPercentage = Math.min(100, Math.max(10, settings.colorSwapAffectPercentage));
        }
      } else {
        // Incorrect Answer Adjustments
        if (incorrectAnswersCount % settings.everyIncorrectLevel === 0) {
          settings.level += settings.levelChangeByIncorrect;
          settings.level = Math.max(1, settings.level);
        }
        if (settings.ballSpeedChangeByIncorrect !== 0 && incorrectAnswersCount % settings.everyIncorrectBallSpeed === 0) {
          settings.ballSpeed += settings.ballSpeedChangeByIncorrect;
          settings.ballSpeed = Math.max(0, settings.ballSpeed);
        }
        if (settings.highlightDurationChangeByIncorrect !== 0 && incorrectAnswersCount % settings.everyIncorrectHighlightDuration === 0) {
          settings.highlightDuration += settings.highlightDurationChangeByIncorrect;
          settings.highlightDuration = Math.max(0, settings.highlightDuration);
        }
        if (settings.delayAfterChangeByIncorrect !== 0 && incorrectAnswersCount % settings.everyIncorrectDelayAfter === 0) {
          settings.delayAfterSequence += settings.delayAfterChangeByIncorrect;
          settings.delayAfterSequence = Math.max(0, settings.delayAfterSequence);
        }

        if (settings.speedBurstMode && incorrectAnswersCount % settings.everyIncorrectSpeedBurst === 0) {
          settings.speedBurstFrequencyMin += settings.speedBurstFrequencyChangeByIncorrect;
          settings.speedBurstFrequencyMax += settings.speedBurstFrequencyChangeByIncorrect;
          settings.speedBurstFrequencyMin = Math.max(500, settings.speedBurstFrequencyMin);
          settings.speedBurstFrequencyMax = Math.max(500, settings.speedBurstFrequencyMax);

          settings.speedBurstMultiplierMax += settings.speedBurstMultiplierChangeByIncorrect;
          settings.speedBurstMultiplierMax = Math.min(5.0, Math.max(0.1, settings.speedBurstMultiplierMax));
        }

        if (settings.colorSwapMode && incorrectAnswersCount % settings.everyIncorrectColorSwap === 0) {
          settings.colorSwapFrequencyMin += settings.colorSwapFrequencyChangeByIncorrect;
          settings.colorSwapFrequencyMax += settings.colorSwapFrequencyChangeByIncorrect;
          settings.colorSwapFrequencyMin = Math.max(1000, settings.colorSwapFrequencyMin);
          settings.colorSwapFrequencyMax = Math.max(1000, settings.colorSwapFrequencyMax);

          settings.colorSwapAffectPercentage += settings.colorSwapAffectPercentageChangeByIncorrect;
          settings.colorSwapAffectPercentage = Math.min(100, Math.max(10, settings.colorSwapAffectPercentage));
        }
      }
      repopulateGui();
      saveSettings();
    }

    function showCorrectSequence() {
      for (let i = 0; i < targetSequence.length; i++) {
        let target = targetSequence[i];
        // Remove existing label if any
        if (target.ball.userData.label) {
          disposeLabel(target.ball.userData.label);
          target.ball.remove(target.ball.userData.label);
          target.ball.userData.label = null;
        }
        // Vibrant green with glow for correct answers
        target.ball.material.color.set(0x00FF00); // Bright vibrant green
        target.ball.material.emissive.set(0x00FF00); // Green glow
        target.ball.material.emissiveIntensity = 0.5; // Strong glow
        addNumberLabel(target.ball, i + 1); // Add number label
      }
    }

    function startColorSwapMode() {
      if (!settings.colorSwapMode) return;

      balls.forEach(ball => {
        ball.userData.initialColor = ball.userData.originalColor;
      });

      scheduleNextColorSwap();
    }

    function scheduleNextColorSwap() {
      if (!settings.colorSwapMode || colorSwapScheduled) return;

      const interval = getRandomInRange(settings.colorSwapFrequencyMin, settings.colorSwapFrequencyMax);
      colorSwapScheduled = true;

      const timeout = setTimeout(() => {
        if (settings.colorSwapMode && !isUserTurn) {
          triggerColorSwap();
        }
        colorSwapScheduled = false;
        scheduleNextColorSwap();
      }, interval);

      colorSwapTimeouts.push(timeout);
    }

    function triggerColorSwap() {
      let eligibleBalls = [];

      if (settings.colorSwapTargetBehavior === 'all') {
        eligibleBalls = balls;
      } else if (settings.colorSwapTargetBehavior === 'targetsOnly') {
        eligibleBalls = targetBalls;
      } else if (settings.colorSwapTargetBehavior === 'distractorsOnly') {
        eligibleBalls = [...distractorBalls, ...coloredDistractorBalls];
      }

      if (eligibleBalls.length === 0) return;

      const numBallsToAffect = Math.ceil((eligibleBalls.length * settings.colorSwapAffectPercentage) / 100);
      const shuffledBalls = shuffleArray([...eligibleBalls]);
      const selectedBalls = shuffledBalls.slice(0, numBallsToAffect);

      for (let i = 0; i < selectedBalls.length; i++) {
        const ball = selectedBalls[i];
        const targetColor = getRandomColor([ball.material.color.getHex()]);
        applyColorSwap(ball, targetColor);
      }
    }

    function applyColorSwap(ball, targetColor) {
      if (ball.userData.isColorSwapping) return;

      ball.userData.isColorSwapping = true;
      ball.userData.swapStartColor = ball.material.color.getHex();
      ball.userData.targetColor = targetColor;
      ball.userData.colorSwapStartTime = Date.now();
      ball.userData.colorSwapProgress = 0;

      activeColorSwaps.push({
        ball: ball,
        startColor: ball.userData.swapStartColor,
        targetColor: targetColor,
        startTime: Date.now(),
        duration: settings.colorSwapDuration
      });

      if (settings.colorSwapVisualEffect) {
        createColorSwapEffect(ball);
      }
    }

    function updateColorSwaps() {
      const now = Date.now();

      for (let i = activeColorSwaps.length - 1; i >= 0; i--) {
        const swap = activeColorSwaps[i];
        const elapsed = now - swap.startTime;
        const progress = Math.min(elapsed / swap.duration, 1.0);

        const easedProgress = progress < 0.5
          ? 2 * progress * progress
          : 1 - Math.pow(-2 * progress + 2, 2) / 2;

        const startColor = new THREE.Color(swap.startColor);
        const targetColor = new THREE.Color(swap.targetColor);
        const currentColor = startColor.lerp(targetColor, easedProgress);

        swap.ball.material.color.copy(currentColor);
        swap.ball.userData.colorSwapProgress = progress;

        if (progress >= 1.0) {
          swap.ball.userData.isColorSwapping = false;
          swap.ball.userData.originalColor = swap.targetColor;
          activeColorSwaps.splice(i, 1);
        }
      }
    }

    function createColorSwapEffect(ball) {
      const flashMaterial = new THREE.MeshBasicMaterial({
        color: 0xFFFFFF,
        transparent: true,
        opacity: 0.8
      });
      const flashSphere = new THREE.Mesh(
        new THREE.SphereGeometry(1.7, 16, 16),
        flashMaterial
      );
      flashSphere.position.copy(ball.position);
      scene.add(flashSphere);

      const ringGeometry = new THREE.RingGeometry(1.5, 1.8, 16);
      const ringMaterial = new THREE.MeshBasicMaterial({
        color: 0xFFFFFF,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 1.0
      });
      const ring = new THREE.Mesh(ringGeometry, ringMaterial);
      ring.position.copy(ball.position);
      ring.lookAt(camera.position);
      scene.add(ring);

      const startTime = Date.now();
      const duration = 300;

      function animateEffect() {
        const elapsed = Date.now() - startTime;
        const progress = elapsed / duration;

        if (progress < 1.0) {
          flashMaterial.opacity = 0.8 * (1 - progress);
          flashSphere.scale.setScalar(1 + progress * 0.3);

          ringMaterial.opacity = 1.0 * (1 - progress);
          ring.scale.setScalar(1 + progress * 2);

          requestAnimationFrame(animateEffect);
        } else {
          scene.remove(flashSphere);
          scene.remove(ring);
          flashSphere.geometry.dispose();
          flashMaterial.dispose();
          ring.geometry.dispose();
          ringMaterial.dispose();
        }
      }

      animateEffect();
    }

    function clearColorSwapTimeouts() {
      colorSwapTimeouts.forEach(timeout => clearTimeout(timeout));
      colorSwapTimeouts = [];
      colorSwapScheduled = false;
      activeColorSwaps = [];

      balls.forEach(ball => {
        ball.userData.isColorSwapping = false;
        if (ball.userData.initialColor !== null) {
          ball.material.color.set(ball.userData.initialColor);
          ball.userData.originalColor = ball.userData.initialColor;
        }
      });
    }

    function startSpeedBurstMode() {
      if (!settings.speedBurstMode) return;
      scheduleNextSpeedBurst();
    }

    function scheduleNextSpeedBurst() {
      if (!settings.speedBurstMode || speedBurstScheduled) return;

      const interval = getRandomInRange(settings.speedBurstFrequencyMin, settings.speedBurstFrequencyMax);
      speedBurstScheduled = true;

      const timeout = setTimeout(() => {
        if (settings.speedBurstMode && !isUserTurn) {
          triggerSpeedBurst();
        }
        speedBurstScheduled = false;
        scheduleNextSpeedBurst();
      }, interval);

      speedBurstTimeouts.push(timeout);
    }

    function triggerSpeedBurst() {
      let eligibleBalls = settings.speedBurstAffectTargetsOnly ? targetBalls : balls;

      if (eligibleBalls.length === 0) return;

      const numBallsToAffect = Math.ceil((eligibleBalls.length * settings.speedBurstAffectPercentage) / 100);
      const shuffledBalls = shuffleArray([...eligibleBalls]);
      const selectedBalls = shuffledBalls.slice(0, numBallsToAffect);

      selectedBalls.forEach(ball => {
        const multiplier = getRandomInRange(settings.speedBurstMultiplierMin, settings.speedBurstMultiplierMax);
        applySpeedBurst(ball, multiplier, settings.speedBurstDuration);
      });
    }

    function applySpeedBurst(ball, multiplier, duration) {
      if (!ball.userData.baseSpeed) {
        if (ball.userData.isRotating) {
          ball.userData.baseSpeed = ball.userData.rotationSpeed;
        } else {
          ball.userData.baseSpeed = ball.userData.velocity.length();
        }
      }

      ball.userData.currentSpeedMultiplier = multiplier;
      ball.userData.isSpeedBursting = true;
      ball.userData.speedBurstEndTime = Date.now() + duration;

      if (multiplier > 1.0) {
        ball.material.emissive.set(0x0088FF);
        ball.material.emissiveIntensity = 0.3;
      } else {
        ball.material.emissive.set(0x8800FF);
        ball.material.emissiveIntensity = 0.3;
      }

      if (ball.userData.isRotating) {
        ball.userData.rotationSpeed = ball.userData.baseSpeed * multiplier;
      } else {
        const direction = ball.userData.velocity.clone().normalize();
        ball.userData.velocity.copy(direction.multiplyScalar(ball.userData.baseSpeed * multiplier * settings.ballSpeed / 0.1));
      }

      const timeout = setTimeout(() => resetSpeedBurst(ball), duration);
      speedBurstTimeouts.push(timeout);
    }

    function resetSpeedBurst(ball) {
      if (!ball.userData.isSpeedBursting) return;

      ball.userData.currentSpeedMultiplier = 1.0;
      ball.userData.isSpeedBursting = false;

      if (!ball.userData.isCurrentlyHighlighted && !ball.userData.isFlashing) {
        ball.material.emissive.set(0xFFFFFF);
        ball.material.emissiveIntensity = 0.05;
      }

      if (ball.userData.baseSpeed) {
        if (ball.userData.isRotating) {
          ball.userData.rotationSpeed = ball.userData.baseSpeed;
        } else {
          const direction = ball.userData.velocity.clone().normalize();
          ball.userData.velocity.copy(direction.multiplyScalar(ball.userData.baseSpeed * settings.ballSpeed / 0.1));
        }
      }
    }

    function clearSpeedBurstTimeouts() {
      speedBurstTimeouts.forEach(timeout => clearTimeout(timeout));
      speedBurstTimeouts = [];
      speedBurstScheduled = false;

      balls.forEach(ball => {
        if (ball.userData.isSpeedBursting) {
          resetSpeedBurst(ball);
        }
      });
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();

      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);

      const delta = clock.getDelta();

      // Optimized: Make only LABELS look at camera, not entire balls
      balls.forEach(ball => {
        if (ball.userData.label && ball.userData.label.visible) {
          ball.userData.label.lookAt(camera.position);
        }
      });

      // Update balls position with delta time for frame-rate independence
      if (!isUserTurn) {
        updateBallPositions(delta);
      }

      updateColorSwaps();

      // Screen Rotation with delta time
      if (settings.screenRotation) {
        updateScreenRotation(delta);
      }

      controls.update();
      renderer.render(scene, camera);
    }

    function updateScreenRotation(delta) {
      screenRotationAngle += settings.screenRotationSpeed;
      let radius = settings.screenRotationDistance;

      // Adjust radius if varyRotationDistance is enabled
      if (settings.varyRotationDistance) {
        radius += Math.sin(screenRotationAngle * 0.5) * 10;
      }

      // Calculate camera position to maintain constant distance
      let x = camera.position.x;
      let y = camera.position.y;
      let z = camera.position.z;

      if (settings.rotateX && settings.rotateY && settings.rotateZ) {
        // Rotate around all axes while keeping constant distance
        const theta = screenRotationAngle;
        const phi = Math.acos(Math.sin(screenRotationAngle * 0.7));
        x = radius * Math.sin(phi) * Math.cos(theta);
        y = radius * Math.cos(phi);
        z = radius * Math.sin(phi) * Math.sin(theta);
      } else {
        // Handle individual axis rotations
        let position = new THREE.Vector3();
        if (settings.rotateX) {
          position.x = radius * Math.sin(screenRotationAngle);
        } else {
          position.x = camera.position.x;
        }
        if (settings.rotateY) {
          position.y = radius * Math.sin(screenRotationAngle * 0.7);
        } else {
          position.y = camera.position.y;
        }
        if (settings.rotateZ) {
          position.z = radius * Math.cos(screenRotationAngle);
        } else {
          position.z = camera.position.z;
        }
        x = position.x;
        y = position.y;
        z = position.z;
      }

      camera.position.set(x, y, z);
      camera.lookAt(scene.position);
    }

    function updateBallPositions(delta) {
      // Normalize delta to 60fps for consistent movement (delta is typically ~0.016 at 60fps)
      const frameMultiplier = delta * 60;

      // Separate moving balls from rotating balls for optimized collision detection
      const movingBalls = [];

      for (let ball of balls) {
        if (ball.userData.isRotating) {
          // Rotation movement (no collision check needed)
          ball.userData.rotationAngle += ball.userData.rotationSpeed;
          const angle = ball.userData.rotationAngle;
          const radius = ball.userData.rotationRadius;

          if (ball.userData.rotationAxis === 'vertical') {
            // Vertical rotation around Y-axis
            ball.position.x = radius * Math.cos(angle);
            ball.position.z = radius * Math.sin(angle);
          } else {
            // Horizontal rotation around X-axis
            ball.position.y = radius * Math.sin(angle);
            ball.position.z = radius * Math.cos(angle);
          }
        } else {
          // Linear movement with delta time for frame-rate independence
          const velocity = ball.userData.velocity.clone().multiplyScalar(frameMultiplier);
          ball.position.add(velocity);

          // Bounce off walls
          const halfBox = settings.boxSize / 2 - 2;
          if (ball.position.x > halfBox || ball.position.x < -halfBox) {
            ball.userData.velocity.x *= -1;
            ball.position.x = THREE.MathUtils.clamp(ball.position.x, -halfBox, halfBox);
          }
          if (ball.position.y > halfBox || ball.position.y < -halfBox) {
            ball.userData.velocity.y *= -1;
            ball.position.y = THREE.MathUtils.clamp(ball.position.y, -halfBox, halfBox);
          }
          if (ball.position.z > halfBox || ball.position.z < -halfBox) {
            ball.userData.velocity.z *= -1;
            ball.position.z = THREE.MathUtils.clamp(ball.position.z, -halfBox, halfBox);
          }

          movingBalls.push(ball);
        }
      }

      // Optimized: Only check collisions between moving balls (skip rotating balls)
      for (let i = 0; i < movingBalls.length; i++) {
        for (let j = i + 1; j < movingBalls.length; j++) {
          const ball1 = movingBalls[i];
          const ball2 = movingBalls[j];
          const distance = ball1.position.distanceTo(ball2.position);
          if (distance < 3) {
            // Simple collision response - swap velocities
            const temp = ball1.userData.velocity.clone();
            ball1.userData.velocity.copy(ball2.userData.velocity);
            ball2.userData.velocity.copy(temp);
          }
        }
      }
    }

    // Flash Mode Functions
    function startFlashMode() {
      if (!settings.flashMode) return;

      // Schedule the next flash
      const intervalDuration = getRandomInRange(settings.intervalDurationMin, settings.intervalDurationMax);
      let timeout = setTimeout(() => {
        flashRandomBalls();
        startFlashMode(); // Schedule the next flash
      }, intervalDuration);
      flashModeTimeouts.push(timeout);
    }

    function flashRandomBalls() {
      // Determine flash duration
      const flashDuration = getRandomInRange(settings.flashDurationMin, settings.flashDurationMax);

      // Get eligible balls (exclude currently highlighted target balls)
      const eligibleBalls = balls.filter(ball => !ball.userData.isCurrentlyHighlighted);

      if (eligibleBalls.length === 0) return;

      // Randomly select a subset of eligible balls
      const numberOfBallsToFlash = Math.floor(Math.random() * eligibleBalls.length) + 1;
      const ballsToFlash = shuffleArray(eligibleBalls).slice(0, numberOfBallsToFlash);

      // Make selected balls invisible
      ballsToFlash.forEach(ball => {
        ball.visible = false;
        ball.userData.isFlashing = true;
      });

      // Restore visibility after flash duration
      let timeout = setTimeout(() => {
        ballsToFlash.forEach(ball => {
          ball.visible = true;
          ball.userData.isFlashing = false;
        });
      }, flashDuration);
      flashModeTimeouts.push(timeout);
    }

    function clearFlashModeTimeouts() {
      flashModeTimeouts.forEach(timeout => clearTimeout(timeout));
      flashModeTimeouts = [];
      // Ensure all balls are visible
      balls.forEach(ball => {
        if (ball.userData.isFlashing) {
          ball.visible = true;
          ball.userData.isFlashing = false;
        }
      });
    }

    // Touch Controls for Mobile (now using TouchControls class from js/touch-controls.js)
    // Old code commented out - now using imported modules
    /*
    let touchState = {...};
    function setupTouchControls() {...}
    function getTouchDistance(touches) {...}
    function onTouchStart(event) {...}
    function onTouchMove(event) {...}
    function onTouchEnd(event) {...}
    */

    // Utility functions (now imported from js/utils.js)
    // Old code commented out - now using imported modules  
    /*
    function showLoading(progress) {...}
    function hideLoading() {...}
    function vibrateDevice(pattern) {...}
    function resetCamera() {...}
    function toggleFullscreen() {...}
    */

    // Utility Functions (now imported from js/utils.js)
    /*
    function shuffleArray(array) {...}
    function generateNonConsecutiveNumbers(count) {...}
    */

    function getRandomColor(excludeColors) {
      // Define a palette of accessible, high-contrast colors
      // Explicitly excluding special feedback colors: 0x00FF00 (green), 0xFF0000 (red), 0xFF6600 (orange)
      const accessibleColors = [
        0x9C27B0, // Purple
        0x00BCD4, // Cyan
        0xFF5722, // Deep Orange (different from feedback orange)
        0x8BC34A, // Light Green (different from feedback green)
        0x3F51B5, // Indigo
        0x009688, // Teal
        0xE91E63, // Pink
        0xCDDC39, // Lime
        0xFFEB3B, // Yellow
        0x795548, // Brown
      ];

      // Always exclude the special feedback colors
      const specialFeedbackColors = [0x00FF00, 0xFF0000, 0xFF6600];
      const allExcludedColors = [...excludeColors, ...specialFeedbackColors];

      // Filter out all excluded colors
      const availableColors = accessibleColors.filter(color => !allExcludedColors.includes(color));

      if (availableColors.length === 0) {
        console.warn('getRandomColor: No available colors, returning fallback');
        return 0x9C27B0; // Purple as fallback
      }

      // Return random color from available palette
      return availableColors[Math.floor(Math.random() * availableColors.length)];
    }

    function getRandomInRange(min, max) {
      return Math.random() * (max - min) + min;
    }

    // ============================================
    // PWA: Service Worker Registration & Install Prompt
    // ============================================

    let deferredPrompt;
    let installButton;

    // Register service worker
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/service-worker.js')
          .then((registration) => {
            console.log('[PWA] Service Worker registered:', registration);

            // Check for updates
            registration.addEventListener('updatefound', () => {
              const newWorker = registration.installing;
              newWorker.addEventListener('statechange', () => {
                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                  // New service worker available
                  console.log('[PWA] New version available! Please refresh.');
                  showUpdateNotification();
                }
              });
            });
          })
          .catch((error) => {
            console.error('[PWA] Service Worker registration failed:', error);
          });
      });
    }

    // Show update notification
    function showUpdateNotification() {
      const notification = document.createElement('div');
      notification.id = 'update-notification';
      notification.style.cssText = `
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: rgba(102, 126, 234, 0.95);
        color: white;
        padding: 15px 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        z-index: 10000;
        font-family: Arial, sans-serif;
        display: flex;
        align-items: center;
        gap: 10px;
      `;
      notification.innerHTML = `
        <span>New version available!</span>
        <button onclick="window.location.reload()" style="
          background: white;
          color: #667eea;
          border: none;
          padding: 5px 15px;
          border-radius: 4px;
          cursor: pointer;
          font-weight: bold;
        ">Update</button>
        <button onclick="this.parentElement.remove()" style="
          background: transparent;
          color: white;
          border: 1px solid white;
          padding: 5px 15px;
          border-radius: 4px;
          cursor: pointer;
        ">Later</button>
      `;
      document.body.appendChild(notification);
    }

    // Listen for beforeinstallprompt event
    window.addEventListener('beforeinstallprompt', (e) => {
      console.log('[PWA] beforeinstallprompt event fired');
      e.preventDefault();
      deferredPrompt = e;
      showInstallButton();
    });

    // Show install button
    function showInstallButton() {
      // Create install button if it doesn't exist
      if (!installButton) {
        installButton = document.createElement('button');
        installButton.id = 'install-button';
        installButton.textContent = 'üì± Install App';
        installButton.style.cssText = `
          position: fixed;
          bottom: 20px;
          left: 20px;
          background: rgba(102, 126, 234, 0.95);
          color: white;
          border: none;
          padding: 12px 20px;
          border-radius: 8px;
          cursor: pointer;
          font-family: Arial, sans-serif;
          font-size: 14px;
          font-weight: bold;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
          z-index: 10000;
          transition: all 0.3s ease;
        `;

        installButton.addEventListener('mouseenter', () => {
          installButton.style.transform = 'translateY(-2px)';
          installButton.style.boxShadow = '0 6px 16px rgba(0, 0, 0, 0.4)';
        });

        installButton.addEventListener('mouseleave', () => {
          installButton.style.transform = 'translateY(0)';
          installButton.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.3)';
        });

        installButton.addEventListener('click', installApp);
        document.body.appendChild(installButton);

        // Auto-hide after 10 seconds
        setTimeout(() => {
          if (installButton) {
            installButton.style.opacity = '0';
            setTimeout(() => {
              if (installButton && installButton.parentElement) {
                installButton.remove();
                installButton = null;
              }
            }, 300);
          }
        }, 10000);
      }
    }

    // Install app
    async function installApp() {
      if (!deferredPrompt) {
        return;
      }

      // Show the install prompt
      deferredPrompt.prompt();

      // Wait for the user's response
      const { outcome } = await deferredPrompt.userChoice;
      console.log(`[PWA] User response to install prompt: ${outcome}`);

      if (outcome === 'accepted') {
        console.log('[PWA] User accepted the install prompt');
      } else {
        console.log('[PWA] User dismissed the install prompt');
      }

      // Clear the deferred prompt
      deferredPrompt = null;

      // Hide install button
      if (installButton) {
        installButton.style.opacity = '0';
        setTimeout(() => {
          if (installButton && installButton.parentElement) {
            installButton.remove();
            installButton = null;
          }
        }, 300);
      }
    }

    // Listen for app installed event
    window.addEventListener('appinstalled', () => {
      console.log('[PWA] App installed successfully');
      deferredPrompt = null;
      if (installButton && installButton.parentElement) {
        installButton.remove();
        installButton = null;
      }
    });

    // Check if app is running in standalone mode (installed)
    if (window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone === true) {
      console.log('[PWA] App is running in standalone mode');
    }

    // ============================================
    // Storage & Data Export
    // ============================================

    // Initialize IndexedDB storage
    storage.init().then(() => {
      console.log('[Storage] Initialized successfully');

      // Migrate data from localStorage to IndexedDB if exists
      migrateFromLocalStorage();
    }).catch((error) => {
      console.error('[Storage] Initialization failed:', error);
    });

    // Migrate existing localStorage data to IndexedDB
    async function migrateFromLocalStorage() {
      const progressData = localStorage.getItem('progressData');
      if (progressData) {
        try {
          const data = JSON.parse(progressData);
          await storage.save('progressData', data);
          console.log('[Storage] Migrated progressData from localStorage to IndexedDB');

          // Optionally remove from localStorage after successful migration
          // localStorage.removeItem('progressData');
        } catch (error) {
          console.error('[Storage] Migration failed:', error);
        }
      }
    }


    // Add storage statistics to console
    storage.getStats().then(stats => {
      console.log('[Storage] Statistics:', stats);
    });

    // Auto-prune old data every 7 days (run on startup)
    const lastPruneKey = 'lastPruneDate';
    storage.get(lastPruneKey).then(lastPrune => {
      const now = Date.now();
      const sevenDays = 7 * 24 * 60 * 60 * 1000;

      if (!lastPrune || (now - lastPrune) > sevenDays) {
        storage.pruneOldData(90).then(deleted => {
          console.log(`[Storage] Pruned ${deleted} old records`);
          storage.save(lastPruneKey, now);
        });
      }
    });

  </script>
</body>

</html>
